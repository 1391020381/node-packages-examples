 * CommonJS的一个模块,就是一个脚本文件。
 * require 命令第一次加载该脚本,就会执行整个脚本,然后内存生成一个对象。

 ```
{
    id:'...',  // 模块名称
    exports:{}, // 模块输出的各个接口
    loaded:true // 一个布尔值 表示该模块的脚本是否执行完毕。
}

 ```
 * 以后需要用到这个模块的时候,就会到exports属性上面取值。即使再次执行 require命令,也不会再次执行该模块,而是到缓存中取值。


 * 循环加载,系统会去a.js模块对应对象的 exports属性取值,可是因为 a.js 还没有执行完,从 exports属性只能取回已经执行的部分,而不是最后的值。


 # ES6模块的循环加载

 * ES6模块的运行机制与CommonJS不一样,它遇到模块加载命令 import时,不会去执行模块,而是只是生成一个引用。等到真的需要用到时,再到模块里面去取值。
 * ES6模块不会缓存运行结果,而是动态地去加载的模块取值,以及变量总是绑定其所在的模块。
 * ES6根本不会关心是否发生了 '循环加载' 只是生成一个指向被加载模块的引用,需要开发者自己保证,真正取值的时候能够取到值。

 * ES6加载的变量,都是动态引用所在的模块,只要引用存在的,代码就能执行。






 # 浏览器加载 CommonJS 模块的原理与实现

 * 浏览器不兼容CommonJS的根本原因,在于缺少四个Nodejs环境的变量。
    - module
    - exports
    - require
    - global



    * CommonJS标准囊括了js需要在服务器端运行所必备的基础能力:比如: 模块化IO操作 二进制字符串  进程管理,Web网关接口(JSGI).